import { OpenAI } from 'openai';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { Anthropic } from '@anthropic-ai/sdk';
import { logger } from './logger';
import { DatabaseError } from './errors';

/**
 * SISTEMA REVOLUCIONARIO DE CHATBOT IA 10.000% MEJORADO
 * Incluye memoria persistente, aprendizaje autom√°tico, an√°lisis de sentimientos,
 * agentes especializados, y mucho m√°s
 */

/**
 * Tipos avanzados para el sistema revolucionario de chatbot
 */
interface UserContext {
  id: string;
  role: 'tenant' | 'owner' | 'broker' | 'provider' | 'admin' | 'runner';
  name: string;
  properties?: any[];
  contracts?: any[];
  payments?: any[];
  preferences?: UserPreferences;
  conversationHistory?: ConversationMemory[];
  sentimentProfile?: SentimentProfile;
  behaviorPatterns?: BehaviorPatterns;
}

interface UserPreferences {
  communicationStyle: 'formal' | 'casual' | 'technical' | 'simple';
  preferredTopics: string[];
  responseLength: 'brief' | 'detailed' | 'comprehensive';
  notificationPreferences: NotificationPrefs;
  language: string;
  timezone: string;
}

interface ConversationMemory {
  id: string;
  timestamp: Date;
  topic: string;
  sentiment: 'positive' | 'negative' | 'neutral' | 'frustrated' | 'urgent';
  outcome: 'resolved' | 'escalated' | 'in_progress' | 'clarification_needed';
  keyEntities: Record<string, any>;
  userSatisfaction?: number;
  agentUsed: string;
}

interface SentimentProfile {
  overallMood: 'positive' | 'negative' | 'neutral';
  frustrationLevel: number;
  urgencyLevel: number;
  confidenceLevel: number;
  topics: Record<string, { sentiment: number; frequency: number }>;
  patterns: SentimentPattern[];
}

interface SentimentPattern {
  trigger: string;
  sentiment: string;
  frequency: number;
  lastOccurrence: Date;
}

interface BehaviorPatterns {
  peakHours: number[];
  preferredChannels: string[];
  commonQuestions: string[];
  successRate: number;
  escalationTriggers: string[];
  preferredSolutions: string[];
}

interface NotificationPrefs {
  email: boolean;
  push: boolean;
  sms: boolean;
  frequency: 'immediate' | 'daily' | 'weekly';
}

interface SecurityContext {
  allowedTopics: string[];
  restrictedTopics: string[];
  maxDataAccess: string;
  canExecuteActions: boolean;
}

interface IntentRecognition {
  intent: string;
  confidence: number;
  entities: Record<string, any>;
  context: string[];
  subIntent?: string | undefined;
  sentiment?: SentimentAnalysis;
  urgency?: number;
  complexity?: 'simple' | 'medium' | 'complex';
}

interface SentimentAnalysis {
  emotion: 'joy' | 'sadness' | 'anger' | 'fear' | 'surprise' | 'disgust' | 'neutral';
  intensity: number;
  confidence: number;
  keywords: string[];
}

interface KnowledgeResponse {
  response: string;
  confidence: number;
  suggestions?: string[] | undefined;
  actions?: string[] | undefined;
  links?: string[] | undefined;
  followUp?: string[] | undefined;
  securityNote?: string | undefined;
  agent?: SpecializedAgent | undefined;
  recommendations?: IntelligentRecommendation[] | undefined;
  sentiment?: SentimentAnalysis | undefined;
  memoryContext?: MemoryContext | undefined;
  learningInsights?: LearningInsight[] | undefined;
}

interface SpecializedAgent {
  id: string;
  name: string;
  specialty: string;
  personality: AgentPersonality;
  expertise: string[];
  language: string;
  avatar?: string;
}

interface AgentPersonality {
  tone: 'professional' | 'friendly' | 'empathetic' | 'technical' | 'humorous';
  formality: 'formal' | 'casual' | 'mixed';
  empathy: number;
  patience: number;
  assertiveness: number;
}

interface IntelligentRecommendation {
  type: 'property' | 'service' | 'contract' | 'payment' | 'maintenance' | 'broker' | 'provider';
  item: any;
  relevanceScore: number;
  reason: string;
  action: string;
}

interface MemoryContext {
  previousTopics: string[];
  unresolvedIssues: string[];
  successfulPatterns: string[];
  userPreferences: Record<string, any>;
  contextSummary: string;
}

interface LearningInsight {
  type: 'success_pattern' | 'failure_pattern' | 'user_preference' | 'topic_trend';
  insight: string;
  confidence: number;
  action: string;
}

/**
 * SISTEMA DE AGENTES ESPECIALIZADOS
 */
interface AgentRegistry {
  [key: string]: SpecializedAgent;
}

/**
 * Configuraci√≥n de proveedores de IA
 */
interface AIProviderConfig {
  provider: 'openai' | 'anthropic' | 'google' | 'local';
  apiKey: string;
  model: string;
  maxTokens: number;
  temperature: number;
}

/**
 * CLASSES AUXILIARES PARA EL SISTEMA REVOLUCIONARIO
 */

/**
 * Analizador de sentimientos avanzado
 */
class SentimentAnalyzer {
  private sentimentPatterns = {
    positive: [
      /(?:estoy|me siento)\s+(?:feliz|contento|satisfecho|agradecido)/i,
      /(?:excelente|genial|fant√°stico|maravilloso|perfecto)/i,
      /(?:gracias|muchas gracias|mil gracias)/i,
      /(?:me encanta|adoro|amo)/i,
      /(?:muy bien|bien hecho|excelente trabajo)/i,
    ],
    negative: [
      /(?:estoy|me siento)\s+(?:molesto|enojado|frustrado|decepcionado)/i,
      /(?:terrible|horrible|muy malo|pesimo)/i,
      /(?:no funciona|no sirve|no vale)/i,
      /(?:odio|detesto|aborrezco)/i,
      /(?:problema|error|fallo|defecto)/i,
    ],
    urgent: [
      /(?:urgente|importante|inmediatamente|ya mismo|ahora)/i,
      /(?:emergencia|cr√≠tico|vital|prioritario)/i,
      /(?:ayuda|socorro|auxilio)/i,
      /(?:r√°pido|pronto|inmediato)/i,
    ],
    frustrated: [
      /(?:siempre|constantemente|todo el tiempo)/i,
      /(?:nunca|jam√°s|ninguna vez)/i,
      /(?:otra vez|de nuevo|repetidamente)/i,
      /(?:cansado|harto|agotado|exasperado)/i,
    ],
  };

  analyze(message: string): SentimentAnalysis {
    const keywords: string[] = [];
    let emotion: SentimentAnalysis['emotion'] = 'neutral';
    let intensity = 0.5;
    let confidence = 0.8;

    // Analizar patrones de sentimientos
    for (const [sentiment, patterns] of Object.entries(this.sentimentPatterns)) {
      for (const pattern of patterns) {
        const matches = message.match(pattern);
        if (matches) {
          keywords.push(matches[0]);
          intensity += 0.2;
          if (intensity > 1) {
            intensity = 1;
          }

          // Determinar emoci√≥n dominante
          if (sentiment === 'positive' && emotion === 'neutral') {
            emotion = 'joy';
          }
          if (sentiment === 'negative' && emotion === 'neutral') {
            emotion = 'anger';
          }
          if (sentiment === 'urgent') {
            emotion = 'fear';
          }
          if (sentiment === 'frustrated' && emotion === 'neutral') {
            emotion = 'sadness';
          }
        }
      }
    }

    // Detectar intensidad por may√∫sculas y signos de exclamaci√≥n
    const uppercaseRatio = (message.match(/[A-Z√Å√â√ç√ì√ö√ë]/g) || []).length / message.length;
    const exclamationCount = (message.match(/!/g) || []).length;

    if (uppercaseRatio > 0.3 || exclamationCount > 2) {
      intensity += 0.3;
      if (emotion === 'anger') {
        confidence += 0.2;
      }
    }

    return {
      emotion,
      intensity: Math.min(intensity, 1),
      confidence,
      keywords: [...new Set(keywords)], // Remover duplicados
    };
  }
}

/**
 * Motor de aprendizaje continuo
 */
class ContinuousLearningEngine {
  private successPatterns: Map<string, number> = new Map();
  private failurePatterns: Map<string, number> = new Map();
  private userPreferences: Map<string, Map<string, number>> = new Map();

  learnFromInteraction(
    userId: string,
    message: string,
    response: string,
    outcome: 'success' | 'failure',
    userSatisfaction?: number
  ): LearningInsight[] {
    const insights: LearningInsight[] = [];

    // Aprender patrones de √©xito/fallo
    const patterns = this.extractPatterns(message);
    for (const pattern of patterns) {
      if (outcome === 'success') {
        const current = this.successPatterns.get(pattern) || 0;
        this.successPatterns.set(pattern, current + 1);
      } else {
        const current = this.failurePatterns.get(pattern) || 0;
        this.failurePatterns.set(pattern, current + 1);
      }
    }

    // Aprender preferencias del usuario
    this.updateUserPreferences(userId, message, response, userSatisfaction);

    // Generar insights
    if (outcome === 'success' && userSatisfaction && userSatisfaction > 4) {
      insights.push({
        type: 'success_pattern',
        insight: `Patr√≥n exitoso identificado: "${patterns[0]}"`,
        confidence: userSatisfaction / 5,
        action: 'Reforzar este tipo de respuesta',
      });
    }

    if (outcome === 'failure' && userSatisfaction && userSatisfaction < 3) {
      insights.push({
        type: 'failure_pattern',
        insight: `Patr√≥n problem√°tico identificado: "${patterns[0]}"`,
        confidence: (5 - userSatisfaction) / 5,
        action: 'Revisar estrategia de respuesta para este patr√≥n',
      });
    }

    return insights;
  }

  private extractPatterns(message: string): string[] {
    const words = message.toLowerCase().split(/\s+/);
    const patterns: string[] = [];

    // Extraer frases de 2-3 palabras
    for (let i = 0; i < words.length - 1; i++) {
      patterns.push(words.slice(i, i + 2).join(' '));
      if (i < words.length - 2) {
        patterns.push(words.slice(i, i + 3).join(' '));
      }
    }

    return patterns;
  }

  private updateUserPreferences(
    userId: string,
    message: string,
    response: string,
    satisfaction?: number
  ): void {
    if (!this.userPreferences.has(userId)) {
      this.userPreferences.set(userId, new Map());
    }

    const userPrefs = this.userPreferences.get(userId)!;

    // Aprender preferencias basadas en satisfacci√≥n
    if (satisfaction) {
      const responseLength =
        response.length < 100 ? 'brief' : response.length < 300 ? 'medium' : 'detailed';
      const currentPref = userPrefs.get(responseLength) || 0;
      userPrefs.set(responseLength, currentPref + (satisfaction > 3 ? 1 : -1));
    }
  }

  getInsights(userId?: string): LearningInsight[] {
    const insights: LearningInsight[] = [];

    // Insights sobre patrones exitosos
    for (const [pattern, count] of this.successPatterns.entries()) {
      if (count > 5) {
        insights.push({
          type: 'success_pattern',
          insight: `Patr√≥n altamente exitoso: "${pattern}" (${count} veces)`,
          confidence: Math.min(count / 10, 1),
          action: 'Priorizar respuestas similares para este patr√≥n',
        });
      }
    }

    // Insights sobre patrones problem√°ticos
    for (const [pattern, count] of this.failurePatterns.entries()) {
      if (count > 3) {
        insights.push({
          type: 'failure_pattern',
          insight: `Patr√≥n problem√°tico: "${pattern}" (${count} veces)`,
          confidence: Math.min(count / 5, 1),
          action: 'Desarrollar estrategia alternativa para este patr√≥n',
        });
      }
    }

    // Insights de usuario espec√≠fico
    if (userId && this.userPreferences.has(userId)) {
      const userPrefs = this.userPreferences.get(userId)!;
      const preferredLength = Array.from(userPrefs.entries()).sort(([, a], [, b]) => b - a)[0]?.[0];

      if (preferredLength) {
        insights.push({
          type: 'user_preference',
          insight: `Usuario prefiere respuestas ${preferredLength}`,
          confidence: 0.8,
          action: `Adaptar longitud de respuestas a ${preferredLength}`,
        });
      }
    }

    return insights;
  }
}

/**
 * Servicio de IA para Chatbot
 */
export class AIChatbotService {
  private openai: OpenAI | null = null;
  private anthropic: Anthropic | null = null;
  private googleAI: GoogleGenerativeAI | null = null;
  private config: AIProviderConfig | null = null;

  // SISTEMA REVOLUCIONARIO: Memoria conversacional persistente
  private conversationMemory: Map<string, ConversationMemory[]> = new Map();

  // SISTEMA REVOLUCIONARIO: Aprendizaje autom√°tico
  private learningDatabase: Map<string, LearningInsight[]> = new Map();

  // SISTEMA REVOLUCIONARIO: An√°lisis de sentimientos avanzado
  private sentimentAnalyzer: SentimentAnalyzer;

  // SISTEMA REVOLUCIONARIO: Agentes especializados
  private agentRegistry: AgentRegistry = {
    general_assistant: {
      id: 'general_assistant',
      name: 'Ana',
      specialty: 'Asistente General',
      personality: {
        tone: 'friendly',
        formality: 'casual',
        empathy: 8,
        patience: 9,
        assertiveness: 6,
      },
      expertise: ['general', 'navigation', 'support'],
      language: 'es',
    },
    property_expert: {
      id: 'property_expert',
      name: 'Carlos',
      specialty: 'Experto en Propiedades',
      personality: {
        tone: 'professional',
        formality: 'formal',
        empathy: 7,
        patience: 8,
        assertiveness: 7,
      },
      expertise: ['properties', 'real_estate', 'contracts', 'rentals'],
      language: 'es',
    },
    financial_advisor: {
      id: 'financial_advisor',
      name: 'Mar√≠a',
      specialty: 'Asesora Financiera',
      personality: {
        tone: 'professional',
        formality: 'formal',
        empathy: 8,
        patience: 7,
        assertiveness: 8,
      },
      expertise: ['payments', 'finances', 'contracts', 'commissions'],
      language: 'es',
    },
    technical_support: {
      id: 'technical_support',
      name: 'Diego',
      specialty: 'Soporte T√©cnico',
      personality: {
        tone: 'technical',
        formality: 'mixed',
        empathy: 6,
        patience: 9,
        assertiveness: 5,
      },
      expertise: ['technical', 'maintenance', 'system', 'troubleshooting'],
      language: 'es',
    },
    maintenance_specialist: {
      id: 'maintenance_specialist',
      name: 'Luis',
      specialty: 'Especialista en Mantenimiento',
      personality: {
        tone: 'empathetic',
        formality: 'casual',
        empathy: 9,
        patience: 8,
        assertiveness: 6,
      },
      expertise: ['maintenance', 'repairs', 'providers', 'emergency'],
      language: 'es',
    },
    broker_consultant: {
      id: 'broker_consultant',
      name: 'Valentina',
      specialty: 'Consultora de Corredores',
      personality: {
        tone: 'professional',
        formality: 'formal',
        empathy: 7,
        patience: 8,
        assertiveness: 8,
      },
      expertise: ['brokers', 'commissions', 'clients', 'market_trends'],
      language: 'es',
    },
    runner_coordinator: {
      id: 'runner_coordinator',
      name: 'Pedro',
      specialty: 'Coordinador Runner360',
      personality: {
        tone: 'friendly',
        formality: 'casual',
        empathy: 8,
        patience: 7,
        assertiveness: 7,
      },
      expertise: ['runner360', 'inspections', 'visits', 'photography'],
      language: 'es',
    },
    legal_expert: {
      id: 'legal_expert',
      name: 'Gabriela',
      specialty: 'Experta Legal',
      personality: {
        tone: 'professional',
        formality: 'formal',
        empathy: 6,
        patience: 9,
        assertiveness: 7,
      },
      expertise: ['legal', 'contracts', 'regulations', 'compliance'],
      language: 'es',
    },
  };

  // SISTEMA REVOLUCIONARIO: Base de aprendizaje continuo
  private continuousLearning: ContinuousLearningEngine;

  constructor() {
    this.sentimentAnalyzer = new SentimentAnalyzer();
    this.continuousLearning = new ContinuousLearningEngine();
    this.initializeAIProviders();
  }

  /**
   * Base de conocimiento expandida para respuestas contextuales
   */
  private knowledgeBase: Record<string, Record<string, any>> = {
    // Registro y autenticaci√≥n
    register: {
      tenant: {
        responses: [
          'Como inquilino, puedes registrarte gratis en segundos. Solo necesitas email, datos b√°sicos y verificar tu identidad. Una vez registrado, podr√°s buscar propiedades, contactar propietarios y corredores, y gestionar tus contratos.',
          'Para registrarte como inquilino: 1) Ve a "Crear cuenta" 2) Selecciona "Inquilino" 3) Completa nombre, email y tel√©fono 4) Verifica tu email 5) Sube documento de identidad. ¬°Listo para buscar propiedades!',
        ],
        suggestions: ['Buscar propiedades', 'Ver corredores', 'Preparar documentos'],
        links: ['/properties/search', '/auth/register?role=tenant'],
      },
      owner: {
        responses: [
          'Como propietario, el registro incluye verificaci√≥n de identidad y propiedades. Necesitar√°s: RUT, datos de contacto, informaci√≥n bancaria, y detalles de tus propiedades. Esto asegura confianza para inquilinos y corredores.',
          'Para propietarios: 1) Registro con RUT y datos personales 2) Verificaci√≥n de identidad 3) Registro de propiedades con fotos y detalles 4) Configuraci√≥n de pagos 5) Definir preferencias de arriendo. Todo verificado para m√°xima seguridad.',
        ],
        suggestions: ['Registrar propiedad', 'Configurar pagos', 'Ver corredores'],
        links: ['/owner/properties/new', '/auth/register?role=owner'],
      },
      broker: {
        responses: [
          'Los corredores necesitan certificaci√≥n profesional v√°lida. El registro incluye: certificaci√≥n de corredor, datos comerciales, especializaci√≥n, y verificaci√≥n de antecedentes. Solo corredores certificados pueden publicar ofertas.',
          'Para corredores certificados: 1) Registro profesional 2) Subir certificaci√≥n vigente 3) Completar perfil comercial 4) Verificaci√≥n de antecedentes 5) Especializaci√≥n (residencial/comercial). Es gratis comenzar.',
        ],
        suggestions: ['Ver propiedades', 'Contactar propietarios', 'Actualizar certificaci√≥n'],
        links: ['/broker/properties', '/auth/register?role=broker'],
      },
      provider: {
        responses: [
          'Como proveedor de servicios, puedes ofrecer: limpieza, mantenimiento, jardiner√≠a, seguridad, etc. El registro incluye verificaci√≥n de experiencia y certificaciones. Apareces en b√∫squedas cuando propietarios necesitan servicios.',
          'Proveedores verificados: 1) Registro b√°sico 2) Seleccionar servicios ofrecidos 3) Subir certificaciones 4) Definir precios y disponibilidad 5) Verificaci√≥n de antecedentes. Gana dinero ofreciendo servicios a la comunidad.',
        ],
        suggestions: ['Configurar servicios', 'Definir precios', 'Ver oportunidades'],
        links: ['/provider/services/new', '/auth/register?role=provider'],
      },
    },

    // B√∫squeda y visualizaci√≥n de propiedades
    property_search: {
      tenant: {
        responses: [
          'Puedes buscar propiedades por: ubicaci√≥n, precio, habitaciones, ba√±os, tipo (casa/departamento/oficina), amenities. Usa filtros avanzados y guarda b√∫squedas. Los corredores y propietarios responden r√°pido a consultas serias.',
          'B√∫squeda inteligente: filtra por zona, presupuesto, caracter√≠sticas. Contacta directamente propietarios o usa corredores certificados. Runner360 puede hacer visitas presenciales con fotos y videos profesionales.',
        ],
        suggestions: ['Aplicar filtros', 'Contactar corredor', 'Agendar visita'],
        links: ['/properties/search', '/properties/filters'],
      },
      broker: {
        responses: [
          'Como corredor, accedes a propiedades exclusivas y listas privadas. Puedes: publicar ofertas de clientes, buscar propiedades para tus clientes, coordinar visitas con Runner360, gestionar contratos, recibir comisiones autom√°ticas.',
          'Ventajas para corredores: propiedades exclusivas, comisiones garantizadas, contratos digitales, seguimiento autom√°tico de pagos, reportes de rendimiento, soporte 24/7.',
        ],
        suggestions: ['Ver propiedades exclusivas', 'Publicar oferta', 'Gestionar contratos'],
        links: ['/broker/properties', '/broker/clients'],
      },
    },

    // Contratos y legales
    contracts: {
      tenant: {
        responses: [
          'Todos los contratos son digitales, legales y seguros con firma TrustFactory. Incluyen: datos completos, cl√°usulas est√°ndar, firmas electr√≥nicas v√°lidas, almacenamiento seguro, acceso 24/7. Son igual de v√°lidos que contratos en papel.',
          'Contratos digitales: 1) Firma desde cualquier dispositivo 2) Validez legal completa 3) Almacenamiento seguro 4) Copia autom√°tica para ambas partes 5) Recordatorios de vencimiento. M√°s seguro y conveniente que contratos tradicionales.',
        ],
        suggestions: ['Ver mis contratos', 'Firmar contrato', 'Descargar PDF'],
        links: ['/tenant/contracts', '/signatures'],
      },
      owner: {
        responses: [
          'Gestiona contratos digitales con inquilinos y corredores. Incluye: plantillas legales actualizadas, firmas electr√≥nicas v√°lidas, seguimiento autom√°tico de pagos, recordatorios de renovaci√≥n, reportes financieros.',
          'Sistema completo de contratos: generaci√≥n autom√°tica, firmas legales, pagos integrados, renovaciones autom√°ticas, reportes de ingresos, alertas de vencimiento. Todo digital y seguro.',
        ],
        suggestions: ['Crear contrato', 'Ver activos', 'Configurar renovaciones'],
        links: ['/owner/contracts', '/owner/contracts/new'],
      },
    },

    // Pagos y finanzas
    payments: {
      tenant: {
        responses: [
          'Pagos seguros con Khipu: d√©bito autom√°tico, recordatorios, recibos digitales. Puedes configurar pago mensual autom√°tico, recibir alertas de vencimiento, ver historial completo, y cambiar m√©todo de pago cuando quieras.',
          'Sistema de pagos inteligente: 1) Configura d√©bito autom√°tico 2) Recibe recordatorios 3) Paga desde app 4) Recibos instant√°neos 5) Cambia m√©todo f√°cilmente. Nunca pierdas un pago.',
        ],
        suggestions: ['Configurar d√©bito', 'Ver historial', 'Cambiar m√©todo'],
        links: ['/tenant/payments', '/tenant/payments/methods'],
      },
      owner: {
        responses: [
          'Recibes pagos autom√°ticamente el d√≠a 5 de cada mes. Sin intermediarios: Khipu transfiere directamente a tu cuenta. Puedes ver reportes detallados, configurar recordatorios para inquilinos, cambiar datos bancarios, y gestionar pagos pendientes.',
          'Gesti√≥n financiera completa: pagos autom√°ticos, reportes mensuales, alertas de mora, integraci√≥n bancaria, m√∫ltiples m√©todos de pago, an√°lisis de ingresos. Todo sin comisiones ocultas.',
        ],
        suggestions: ['Ver ingresos', 'Configurar cuenta', 'Enviar recordatorios'],
        links: ['/owner/payments', '/owner/payments/reports'],
      },
    },

    // Runner360 y visitas
    runner360: {
      tenant: {
        responses: [
          'Runner360 hace visitas presenciales profesionales: fotos de calidad, videos detallados, reportes completos, medici√≥n exacta, verificaci√≥n de estado. Pagan ellos, t√∫ solo eliges la mejor propiedad.',
          'Visitas profesionales: 1) Runner360 verifica propiedades 2) Fotos y videos HD 3) Reportes detallados 4) Medidas exactas 5) Verificaci√≥n de servicios. Todo gratis para inquilinos, pago por propietarios.',
        ],
        suggestions: ['Agendar visita', 'Ver reportes', 'Comparar propiedades'],
        links: ['/properties/search', '/runner'],
      },
      owner: {
        responses: [
          'Runner360 acelera tus arriendos: visitas profesionales, reportes detallados, m√°s confianza para inquilinos, reducci√≥n de tiempo de vacancia. T√∫ pagas solo por visitas realizadas, precio justo por resultados.',
          'Beneficios Runner360: visitas profesionales, fotos/v√≠deos de calidad, reportes completos, m√°s inter√©s de inquilinos, arriendos m√°s r√°pidos, reducci√≥n de costos de publicidad.',
        ],
        suggestions: ['Agendar visitas', 'Ver reportes', 'Configurar precios'],
        links: ['/owner/properties', '/runner'],
      },
      broker: {
        responses: [
          'Coordina visitas profesionales con Runner360: integrada en tu flujo de trabajo, reportes autom√°ticos, fotos profesionales, reducci√≥n de tiempo en terreno. Tus clientes obtienen mejor servicio, t√∫ cierras m√°s arriendos.',
          'Herramientas para corredores: integraci√≥n Runner360, coordinaci√≥n autom√°tica de visitas, reportes profesionales, reducci√≥n de tiempo de respuesta, mejor satisfacci√≥n de clientes.',
        ],
        suggestions: ['Coordinar visitas', 'Ver reportes', 'Configurar agenda'],
        links: ['/broker/appointments', '/runner'],
      },
      runner: {
        responses: [
          'Como Runner360 ganas dinero flexiblemente: cobra por visita completada, horarios flexibles, zona que elijas, soporte completo. Promedio $15.000-25.000 por visita seg√∫n zona. Sin inversi√≥n inicial.',
          'Oportunidades Runner360: ingresos flexibles, trabajo independiente, zonas preferidas, soporte 24/7, pagos semanales, crecimiento ilimitado. S√© parte de la red de confianza de arriendos.',
        ],
        suggestions: ['Ver oportunidades', 'Configurar perfil', 'Ver ganancias'],
        links: ['/runner/dashboard', '/auth/register?role=runner'],
      },
    },

    // Mantenimiento y reparaciones
    maintenance: {
      tenant: {
        responses: [
          'Para problemas de mantenimiento: 1) Reporta desde tu panel 2) Sube fotos/videos 3) Sistema asigna proveedor autom√°ticamente 4) Seguimiento en tiempo real 5) Pagos seguros. Todo coordinado y garantizado.',
          'Servicio de mantenimiento completo: reporta problemas f√°cilmente, proveedores verificados, seguimiento autom√°tico, garant√≠a de trabajo, pagos seguros. No m√°s dolores de cabeza con reparaciones.',
        ],
        suggestions: ['Reportar problema', 'Ver solicitudes', 'Calificar servicio'],
        links: ['/tenant/maintenance', '/tenant/maintenance/new'],
      },
      owner: {
        responses: [
          'Sistema completo de mantenimiento: proveedores verificados, precios competitivos, seguimiento autom√°tico, garant√≠a de trabajos, reportes de gastos. Mant√©n tus propiedades en perfectas condiciones.',
          'Gesti√≥n de mantenimiento: red de proveedores verificados, presupuestos autom√°ticos, aprobaci√≥n de trabajos, seguimiento GPS, reportes detallados, control de costos.',
        ],
        suggestions: ['Ver solicitudes', 'Aprobar presupuestos', 'Ver reportes'],
        links: ['/owner/maintenance', '/owner/maintenance/reports'],
      },
    },

    // Seguridad y verificaci√≥n
    security: {
      general: {
        responses: [
          'Seguridad total en Rent360: verificaci√≥n de identidad completa, validaci√≥n de documentos, contratos legales, pagos seguros, antecedentes verificados. Toda la informaci√≥n est√° encriptada y protegida.',
          'Sistema de seguridad multi-capa: verificaci√≥n de usuarios, contratos digitales legales, pagos con Khipu, encriptaci√≥n de datos, monitoreo 24/7, cumplimiento legal chileno.',
        ],
        suggestions: ['Verificar cuenta', 'Actualizar documentos', 'Configurar seguridad'],
        links: ['/settings/security', '/verification'],
      },
    },

    // Soporte y ayuda
    support: {
      general: {
        responses: [
          '¬øNecesitas ayuda? Estoy aqu√≠ 24/7. Puedo ayudarte con: registro, propiedades, contratos, pagos, Runner360, mantenimiento, seguridad, y cualquier proceso de la plataforma. Tambi√©n puedes contactar soporte humano.',
          'Centro de ayuda completo: documentaci√≥n detallada, tutoriales paso a paso, soporte por chat, tel√©fono y email, comunidad de usuarios, base de conocimientos actualizada.',
        ],
        suggestions: ['Buscar en ayuda', 'Contactar soporte', 'Ver tutoriales'],
        links: ['/help', '/support', '/contact'],
      },
    },
  };

  /**
   * Sistema avanzado de reconocimiento de intenciones
   */
  private recognizeIntent(
    message: string,
    userRole: string,
    context: string[] = []
  ): IntentRecognition {
    const text = message.toLowerCase().trim();

    // Patrones avanzados de intenci√≥n con pesos y contexto
    const intentPatterns = [
      {
        intent: 'register',
        patterns: [
          /(?:como|d√≥nde|quiero|necesito)\s+(?:registrarme|crear cuenta|darme de alta)/,
          /(?:registro|registrar|unirme|empezar)/,
          /(?:ser|convertirme en|quiero ser)\s+(?:propietario|inquilino|corredor|proveedor|runner)/,
        ],
        weight: 1.0,
        context: ['auth', 'signup', 'join'],
      },
      {
        intent: 'property_search',
        patterns: [
          /(?:buscar|encontrar|ver)\s+(?:propiedad|propiedades|departamento|casa|arriendo)/,
          /(?:quiero|necesito|busco)\s+(?:alquilar|renta|arriendo)/,
          /(?:filtrar|busqueda|search)/,
        ],
        weight: 0.9,
        context: ['properties', 'search', 'rent'],
      },
      {
        intent: 'contracts',
        patterns: [
          /(?:contrato|contratos|firmar|firma|legal|documento)/,
          /(?:como|d√≥nde)\s+(?:firmar|ver|descargar)\s+contrato/,
          /(?:trustfactory|firma electronica|contrato digital)/,
        ],
        weight: 0.95,
        context: ['legal', 'contracts', 'signing'],
      },
      {
        intent: 'payments',
        patterns: [
          /(?:pago|pagos|dinero|pagar|transferencia|banco)/,
          /(?:como|d√≥nde|cu√°ndo)\s+(?:pagar|recibir|transferir)/,
          /(?:khipu|debito|metodo de pago)/,
        ],
        weight: 0.9,
        context: ['finance', 'payments', 'money'],
      },
      {
        intent: 'runner360',
        patterns: [
          /(?:runner|runner360|visita|visitas|recorrido)/,
          /(?:como|d√≥nde|cu√°ndo)\s+(?:visitar|ver)\s+propiedad/,
          /(?:fotos|video|reporte)\s+(?:profesional|visita)/,
        ],
        weight: 0.85,
        context: ['visits', 'inspection', 'runner'],
      },
      {
        intent: 'maintenance',
        patterns: [
          /(?:mantenimiento|reparar|arreglar|problema|da√±o)/,
          /(?:fuga|electricidad|plomeria|pared|techo)/,
          /(?:proveedor|tecnico|servicio)/,
        ],
        weight: 0.8,
        context: ['repair', 'maintenance', 'fix'],
      },
      {
        intent: 'security',
        patterns: [
          /(?:seguridad|seguro|verificar|verificacion|confianza)/,
          /(?:documento|identidad|antecedente|certificado)/,
          /(?:protegido|proteger|fraude|estafa)/,
        ],
        weight: 0.75,
        context: ['security', 'verification', 'trust'],
      },
      {
        intent: 'support',
        patterns: [
          /(?:ayuda|ayudame|problema|soporte|duda|no entiendo)/,
          /(?:como|qu√©|d√≥nde|cu√°ndo|por qu√©)/,
          /(?:contactar|llamar|escribir)\s+(?:soporte|ayuda)/,
        ],
        weight: 0.7,
        context: ['help', 'support', 'question'],
      },
    ];

    let bestIntent = 'support';
    let bestConfidence = 0;
    let bestEntities: Record<string, any> = {};

    // Evaluar cada patr√≥n
    for (const pattern of intentPatterns) {
      for (const regex of pattern.patterns) {
        const matches = text.match(regex);
        if (matches) {
          let confidence = pattern.weight;

          // Ajustar confianza basado en contexto
          if (context.some(ctx => pattern.context.includes(ctx))) {
            confidence += 0.1;
          }

          // Ajustar confianza basado en rol del usuario
          if (this.isIntentRelevantForRole(pattern.intent, userRole)) {
            confidence += 0.05;
          }

          if (confidence > bestConfidence) {
            bestIntent = pattern.intent;
            bestConfidence = confidence;
            bestEntities = this.extractEntities(text, pattern.intent);
          }
        }
      }
    }

    return {
      intent: bestIntent,
      confidence: Math.min(bestConfidence, 1.0),
      entities: bestEntities,
      context: context,
      subIntent: this.detectSubIntent(text, bestIntent),
    };
  }

  /**
   * Verificar si la intenci√≥n es relevante para el rol del usuario
   */
  private isIntentRelevantForRole(intent: string, role: string): boolean {
    const roleRelevance: Record<string, string[]> = {
      tenant: ['property_search', 'contracts', 'payments', 'maintenance', 'runner360'],
      owner: ['property_search', 'contracts', 'payments', 'maintenance', 'runner360'],
      broker: ['property_search', 'contracts', 'payments', 'runner360'],
      provider: ['register', 'maintenance', 'payments'],
      admin: ['security', 'support'],
    };

    return roleRelevance[role]?.includes(intent) || false;
  }

  /**
   * Extraer entidades del mensaje (roles, propiedades, montos, etc.)
   */
  private extractEntities(text: string, intent: string): Record<string, any> {
    const entities: Record<string, any> = {};

    // Extraer roles mencionados
    const rolePatterns = {
      propietario: /propietario|owner/i,
      inquilino: /inquilino|tenant|renter/i,
      corredor: /corredor|broker|agente/i,
      proveedor: /proveedor|provider|servicio/i,
      runner: /runner/i,
    };

    for (const [role, pattern] of Object.entries(rolePatterns)) {
      if (pattern.test(text)) {
        entities.role = role;
      }
    }

    // Extraer montos de dinero
    const moneyMatch = text.match(/\$?(\d{1,3}(?:\.\d{3})*|\d+)(?:\s*(mil|millones?))?/gi);
    if (moneyMatch) {
      entities.amount = moneyMatch[0];
    }

    // Extraer tipos de propiedad
    const propertyTypes = ['departamento', 'casa', 'oficina', 'local', 'bodega'];
    for (const type of propertyTypes) {
      if (text.includes(type)) {
        entities.propertyType = type;
        break;
      }
    }

    // Extraer ubicaciones
    const locations = ['santiago', 'providencia', 'las condes', 'vitacura', '√±u√±oa', 'la florida'];
    for (const location of locations) {
      if (text.includes(location)) {
        entities.location = location;
        break;
      }
    }

    return entities;
  }

  /**
   * Detectar sub-intenciones m√°s espec√≠ficas
   */
  private detectSubIntent(text: string, mainIntent: string): string | undefined {
    const subIntentPatterns: Record<string, RegExp[]> = {
      property_search: [/alquiler|renta|arriendo/i, /venta|comprar/i, /temporal|vacacional/i],
      payments: [/atrasado|mora|vencido/i, /adelantado|avanzado/i, /metodo|cambiar/i],
      contracts: [/renovar|renovacion/i, /terminar|finalizar/i, /modificar|cambiar/i],
    };

    const patterns = subIntentPatterns[mainIntent];
    if (patterns) {
      for (const pattern of patterns) {
        if (pattern.test(text)) {
          return pattern.source.replace(/[/\\^$*+?.()|[\]{}]/g, '').replace(/i$/, '');
        }
      }
    }

    return undefined;
  }

  /**
   * Generar respuesta inteligente basada en intenci√≥n y conocimiento
   */
  private generateSmartResponse(
    intent: IntentRecognition,
    userRole: string,
    securityContext: SecurityContext
  ): KnowledgeResponse {
    const { intent: mainIntent, confidence, entities, subIntent } = intent;

    // Verificar seguridad primero
    if (this.hasSecurityViolation(intent, securityContext)) {
      return {
        response:
          'Lo siento, no puedo proporcionar informaci√≥n sobre ese tema por restricciones de seguridad.',
        confidence: 1.0,
        securityNote: 'Contenido restringido para este rol de usuario',
      };
    }

    // Obtener conocimiento base para la intenci√≥n
    const intentKnowledge = this.knowledgeBase[mainIntent];
    if (!intentKnowledge) {
      return this.generateFallbackResponse(userRole);
    }

    // Obtener respuestas espec√≠ficas del rol
    const roleResponses = intentKnowledge[userRole] || intentKnowledge['general'];
    if (!roleResponses) {
      return this.generateFallbackResponse(userRole);
    }

    // Seleccionar respuesta basada en entidades y contexto
    let selectedResponse = roleResponses.responses[0];
    let suggestions = roleResponses.suggestions || [];
    let links = roleResponses.links || [];

    // Personalizar respuesta basada en entidades detectadas
    if (entities.role && entities.role !== userRole) {
      selectedResponse = this.adaptResponseForRole(selectedResponse, entities.role);
    }

    if (entities.location) {
      selectedResponse = selectedResponse.replace(/ubicaci√≥n/gi, entities.location);
    }

    if (entities.amount) {
      selectedResponse = this.personalizePriceResponse(selectedResponse, entities.amount);
    }

    // Agregar contexto espec√≠fico si hay sub-intenci√≥n
    if (subIntent) {
      const subIntentContext = this.getSubIntentContext(mainIntent, subIntent);
      if (subIntentContext) {
        selectedResponse += '\n\n' + subIntentContext;
        suggestions = [...suggestions, ...subIntentContext.suggestions];
      }
    }

    // Generar preguntas de seguimiento inteligentes
    const followUp = this.generateFollowUpQuestions(mainIntent, userRole, entities);

    return {
      response: selectedResponse,
      confidence,
      suggestions,
      links,
      followUp,
      actions: this.getAvailableActions(mainIntent, userRole),
    };
  }

  /**
   * Verificar violaciones de seguridad
   */
  private hasSecurityViolation(
    intent: IntentRecognition,
    securityContext: SecurityContext
  ): boolean {
    const restrictedWords = [
      'admin',
      'sistema',
      'configuraci√≥n',
      'seguridad',
      'usuario',
      'base de datos',
      'servidor',
      'c√≥digo',
      'hack',
      'vulnerabilidad',
    ];

    const message = intent.intent.toLowerCase();

    // Verificar palabras restringidas
    const hasRestrictedWords = restrictedWords.some(word => message.includes(word));

    // Verificar si el tema est√° restringido para este rol
    const hasRestrictedTopic = securityContext.restrictedTopics.some(topic =>
      message.includes(topic)
    );

    // Si es admin, permitir acceso a todo excepto temas marcados como restringidos
    if (securityContext.allowedTopics.includes('todo')) {
      return hasRestrictedTopic;
    }

    return hasRestrictedWords && hasRestrictedTopic;
  }

  /**
   * Adaptar respuesta para rol espec√≠fico mencionado
   */
  private adaptResponseForRole(response: string, targetRole: string): string {
    const roleDescriptions: Record<string, string> = {
      propietario: 'Como propietario en Rent360',
      inquilino: 'Como inquilino en Rent360',
      corredor: 'Como corredor certificado',
      proveedor: 'Como proveedor de servicios',
      runner: 'Como Runner360',
    };

    return response.replace(
      /Como (inquilino|propietario|corredor|proveedor)/i,
      roleDescriptions[targetRole] || response
    );
  }

  /**
   * Personalizar respuesta basada en precio mencionado
   */
  private personalizePriceResponse(response: string, amount: string): string {
    if (response.includes('precio') || response.includes('pago')) {
      return response.replace(/\$?\d+(?:\.\d{3})*/g, amount);
    }
    return response;
  }

  /**
   * Obtener contexto adicional para sub-intenciones
   */
  private getSubIntentContext(mainIntent: string, subIntent: string): any {
    const subContexts: Record<string, Record<string, any>> = {
      property_search: {
        alquiler: {
          response:
            'Para alquileres, considera: duraci√≥n del contrato, garant√≠as requeridas, y condiciones especiales.',
          suggestions: ['Ver contratos disponibles', 'Calcular garant√≠as'],
        },
        venta: {
          response:
            'Para ventas, eval√∫a: tasaci√≥n oficial, documentos necesarios, y proceso notarial.',
          suggestions: ['Solicitar tasaci√≥n', 'Preparar documentos'],
        },
      },
      payments: {
        atrasado: {
          response:
            'Para pagos atrasados: contacta inmediatamente a tu administrador, revisa recordatorios, y configura alertas.',
          suggestions: ['Ver estado de pagos', 'Configurar alertas', 'Contactar administrador'],
        },
        metodo: {
          response:
            'Puedes cambiar tu m√©todo de pago en cualquier momento desde tu panel de pagos.',
          suggestions: ['Ver m√©todos disponibles', 'Configurar d√©bito autom√°tico'],
        },
      },
      contracts: {
        renovar: {
          response:
            'Para renovar contratos: inicia el proceso 60 d√≠as antes del vencimiento para evitar interrupciones.',
          suggestions: ['Ver contratos pr√≥ximos a vencer', 'Iniciar renovaci√≥n'],
        },
      },
    };

    return subContexts[mainIntent]?.[subIntent];
  }

  /**
   * Generar preguntas de seguimiento inteligentes
   */
  private generateFollowUpQuestions(
    intent: string,
    userRole: string,
    entities: Record<string, any>
  ): string[] {
    const followUps: Record<string, Record<string, string[]>> = {
      property_search: {
        tenant: [
          '¬øEn qu√© zona te gustar√≠a vivir?',
          '¬øCu√°ntas habitaciones necesitas?',
          '¬øCu√°l es tu presupuesto mensual?',
          '¬øTienes mascotas o ni√±os?',
        ],
        broker: [
          '¬øQu√© tipo de propiedad busca tu cliente?',
          '¬øCu√°l es el presupuesto disponible?',
          '¬øNecesitas propiedades exclusivas?',
          '¬øQuieres coordinar visitas con Runner360?',
        ],
      },
      contracts: {
        tenant: [
          '¬øNecesitas ayuda para firmar el contrato?',
          '¬øQuieres revisar las cl√°usulas del contrato?',
          '¬øTienes alguna duda sobre los t√©rminos?',
        ],
        owner: [
          '¬øQuieres configurar renovaciones autom√°ticas?',
          '¬øNecesitas crear un nuevo contrato?',
          '¬øQuieres revisar contratos activos?',
        ],
      },
      payments: {
        tenant: [
          '¬øQuieres configurar d√©bito autom√°tico?',
          '¬øNecesitas cambiar tu m√©todo de pago?',
          '¬øQuieres ver tu historial de pagos?',
        ],
        owner: [
          '¬øQuieres configurar recordatorios autom√°ticos?',
          '¬øNecesitas cambiar tus datos bancarios?',
          '¬øQuieres ver reportes de ingresos?',
        ],
      },
    };

    const roleFollowUps = followUps[intent]?.[userRole] || [];
    return roleFollowUps.slice(0, 2); // M√°ximo 2 preguntas de seguimiento
  }

  /**
   * Obtener acciones disponibles para la intenci√≥n
   */
  private getAvailableActions(intent: string, userRole: string): string[] {
    const actions: Record<string, Record<string, string[]>> = {
      property_search: {
        tenant: ['Buscar propiedades', 'Aplicar filtros', 'Contactar corredor', 'Agendar visita'],
        broker: ['Ver propiedades exclusivas', 'Publicar oferta', 'Coordinar visitas'],
      },
      contracts: {
        tenant: ['Ver mis contratos', 'Firmar contrato', 'Descargar PDF'],
        owner: ['Crear contrato', 'Ver contratos activos', 'Configurar renovaciones'],
      },
      payments: {
        tenant: ['Configurar d√©bito autom√°tico', 'Ver historial', 'Cambiar m√©todo de pago'],
        owner: ['Ver ingresos', 'Configurar cuenta', 'Enviar recordatorios'],
      },
    };

    return actions[intent]?.[userRole] || [];
  }

  /**
   * Generar respuesta de fallback cuando no hay conocimiento espec√≠fico
   */
  private generateFallbackResponse(userRole: string): KnowledgeResponse {
    const fallbackResponses: Record<string, string> = {
      tenant:
        'Soy tu asistente en Rent360. Puedo ayudarte con propiedades, contratos, pagos, mantenimiento y soporte. ¬øEn qu√© puedo ayudarte hoy?',
      owner:
        'Como propietario, puedo ayudarte con tus propiedades, contratos, pagos, inquilinos, mantenimiento y reportes. ¬øQu√© necesitas gestionar?',
      broker:
        'Como corredor certificado, puedo ayudarte con propiedades, contratos, clientes, comisiones y reportes. ¬øC√≥mo puedo asistirte?',
      provider:
        'Como proveedor de servicios, puedo ayudarte con trabajos, pagos, perfil y clientes. ¬øQu√© necesitas?',
      admin:
        'Como administrador, tengo acceso completo al sistema. ¬øQu√© necesitas revisar o configurar?',
    };

    return {
      response:
        fallbackResponses[userRole] || fallbackResponses['tenant'] || '¬øEn qu√© puedo ayudarte?',
      confidence: 0.5,
      suggestions: ['Ver ayuda', 'Contactar soporte', 'Explorar plataforma'],
      links: ['/help', '/support'],
    };
  }

  /**
   * üöÄ SISTEMA REVOLUCIONARIO: Procesar mensaje con IA 10.000% mejorada
   * Incluye memoria conversacional, aprendizaje autom√°tico, agentes especializados,
   * an√°lisis de sentimientos, recomendaciones inteligentes y mucho m√°s
   */
  async processMessageRevolutionary(
    userMessage: string,
    userRole: string,
    userId: string,
    conversationHistory: any[] = [],
    userContext?: Partial<UserContext>
  ): Promise<{
    response: string;
    confidence: number;
    intent: string;
    agent?: SpecializedAgent | undefined;
    recommendations?: IntelligentRecommendation[] | undefined;
    sentiment?: SentimentAnalysis | undefined;
    memoryContext?: MemoryContext | undefined;
    learningInsights?: LearningInsight[] | undefined;
    suggestions?: string[] | undefined;
    actions?: string[] | undefined;
    links?: string[] | undefined;
    followUp?: string[] | undefined;
    securityNote?: string | undefined;
  }> {
    try {
      // üîç PASO 1: An√°lisis de sentimientos avanzado
      const sentiment = this.sentimentAnalyzer.analyze(userMessage);

      // üß† PASO 2: Cargar memoria conversacional del usuario
      const userMemory = this.loadUserMemory(userId);
      const memoryContext = this.buildMemoryContext(userMemory, userMessage);

      // üéØ PASO 3: Reconocimiento de intenci√≥n revolucionario
      const intent = this.recognizeIntentRevolutionary(
        userMessage,
        userRole,
        conversationHistory,
        sentiment,
        memoryContext
      );

      // üîí PASO 4: Validaci√≥n de seguridad con contexto de usuario
      const securityContext = this.createSecurityContext(userRole, userId);

      // ü§ñ PASO 5: Selecci√≥n del agente especializado ideal
      const selectedAgent = this.selectSpecializedAgent(intent, userRole, sentiment, memoryContext);

      // üìä PASO 6: Generar recomendaciones inteligentes
      const recommendations = await this.generateIntelligentRecommendations(
        intent,
        userRole,
        userId,
        userContext
      );

      // üí° PASO 7: Aprendizaje autom√°tico - insights del sistema
      const learningInsights = this.continuousLearning.getInsights(userId);

      // üó£Ô∏è PASO 8: Generar respuesta hiper-inteligente
      const smartResponse = await this.generateRevolutionaryResponse(
        intent,
        userRole,
        securityContext,
        selectedAgent,
        sentiment,
        memoryContext,
        recommendations,
        conversationHistory
      );

      // üìà PASO 9: Aprender de esta interacci√≥n para futuras mejoras
      this.learnFromInteraction(userId, userMessage, smartResponse.response, sentiment);

      // üíæ PASO 10: Guardar en memoria conversacional
      this.saveToMemory(userId, {
        id: Date.now().toString(),
        timestamp: new Date(),
        topic: intent.intent,
        sentiment: sentiment.emotion as any,
        outcome: 'resolved', // Se actualizar√° con feedback posterior
        keyEntities: intent.entities,
        agentUsed: selectedAgent?.id || 'general_assistant',
      });

      return {
        response: smartResponse.response,
        confidence: smartResponse.confidence,
        intent: intent.intent,
        agent: selectedAgent,
        recommendations,
        sentiment,
        memoryContext,
        learningInsights,
        suggestions: smartResponse.suggestions,
        actions: smartResponse.actions,
        links: smartResponse.links,
        followUp: smartResponse.followUp,
        securityNote: smartResponse.securityNote,
      };
    } catch (error) {
      logger.error('Error procesando mensaje revolucionario:', {
        error: error instanceof Error ? error.message : String(error),
        userId,
        userRole,
      });

      // Fallback con agente general
      const fallbackAgent = this.agentRegistry['general_assistant'];
      const fallback = this.generateFallbackResponse(userRole);

      return {
        response: fallback.response,
        confidence: fallback.confidence,
        intent: 'support',
        agent: fallbackAgent,
        suggestions: fallback.suggestions,
        links: fallback.links,
        securityNote: 'Sistema operativo en modo seguro',
      };
    }
  }

  /**
   * üîç Reconocimiento de intenci√≥n revolucionario
   */
  private recognizeIntentRevolutionary(
    message: string,
    userRole: string,
    conversationHistory: any[],
    sentiment: SentimentAnalysis,
    memoryContext: MemoryContext
  ): IntentRecognition {
    const baseIntent = this.recognizeIntent(message, userRole, memoryContext.previousTopics);

    // Mejorar intenci√≥n basada en sentimiento
    if (sentiment.emotion === 'anger' && baseIntent.intent === 'support') {
      baseIntent.intent = 'urgent_support';
    }

    if (sentiment.emotion === 'fear' && sentiment.keywords.includes('urgente')) {
      baseIntent.urgency = 0.9;
    }

    // Mejorar intenci√≥n basada en memoria
    if (memoryContext.unresolvedIssues.length > 0) {
      baseIntent.intent = 'follow_up_previous';
      baseIntent.context.push('has_unresolved_issues');
    }

    // Determinar complejidad
    const wordCount = message.split(' ').length;
    if (wordCount < 5) {
      baseIntent.complexity = 'simple';
    } else if (wordCount < 15) {
      baseIntent.complexity = 'medium';
    } else {
      baseIntent.complexity = 'complex';
    }

    baseIntent.sentiment = sentiment;

    return baseIntent;
  }

  /**
   * ü§ñ Selecci√≥n de agente especializado inteligente
   */
  private selectSpecializedAgent(
    intent: IntentRecognition,
    userRole: string,
    sentiment: SentimentAnalysis,
    memoryContext: MemoryContext
  ): SpecializedAgent | undefined {
    let bestAgent = this.agentRegistry['general_assistant'];
    let bestScore = 0;

    for (const agent of Object.values(this.agentRegistry)) {
      let score = 0;

      // Puntaje por expertise en el tema
      if (agent.expertise.includes(intent.intent)) {
        score += 40;
      }
      if (agent.expertise.some(exp => intent.intent.includes(exp))) {
        score += 20;
      }

      // Puntaje por rol del usuario
      if (this.isAgentSuitableForRole(agent, userRole)) {
        score += 15;
      }

      // Puntaje por personalidad y sentimiento
      if (sentiment.emotion === 'anger' && agent.personality.empathy > 7) {
        score += 10;
      }
      if (sentiment.emotion === 'fear' && agent.personality.patience > 8) {
        score += 10;
      }
      if (sentiment.intensity > 0.7 && agent.personality.empathy > 6) {
        score += 5;
      }

      // Puntaje por memoria (continuidad)
      if (
        memoryContext.previousTopics.length > 0 &&
        agent.expertise.some(exp => memoryContext.previousTopics.includes(exp))
      ) {
        score += 10;
      }

      // Bonus por ser especialista vs general
      if (agent.id !== 'general_assistant') {
        score += 5;
      }

      if (score > bestScore) {
        bestScore = score;
        bestAgent = agent;
      }
    }

    return bestAgent;
  }

  /**
   * üìä Generar recomendaciones inteligentes
   */
  private async generateIntelligentRecommendations(
    intent: IntentRecognition,
    userRole: string,
    userId: string,
    userContext?: Partial<UserContext>
  ): Promise<IntelligentRecommendation[]> {
    const recommendations: IntelligentRecommendation[] = [];

    // Recomendaciones basadas en intenci√≥n
    if (intent.intent === 'property_search' && userRole === 'tenant') {
      // Buscar propiedades similares a las que ha visto antes
      const recentProperties = userContext?.properties || [];
      if (recentProperties.length > 0) {
        recommendations.push({
          type: 'property',
          item: { similarTo: recentProperties[0] },
          relevanceScore: 0.85,
          reason: 'Basado en tus b√∫squedas recientes',
          action: 'Ver propiedades similares',
        });
      }
    }

    if (intent.intent === 'payments' && userRole === 'owner') {
      recommendations.push({
        type: 'payment',
        item: { type: 'automatic_collection' },
        relevanceScore: 0.9,
        reason: 'Reduce mora y facilita cobros',
        action: 'Configurar cobros autom√°ticos',
      });
    }

    if (intent.intent === 'maintenance' && userRole === 'tenant') {
      recommendations.push({
        type: 'service',
        item: { category: 'emergency_repair' },
        relevanceScore: 0.8,
        reason: 'Servicio r√°pido y garantizado',
        action: 'Contactar especialista cercano',
      });
    }

    return recommendations.slice(0, 3); // M√°ximo 3 recomendaciones
  }

  /**
   * üó£Ô∏è Generar respuesta revolucionaria
   */
  private async generateRevolutionaryResponse(
    intent: IntentRecognition,
    userRole: string,
    securityContext: SecurityContext,
    agent: SpecializedAgent | undefined,
    sentiment: SentimentAnalysis,
    memoryContext: MemoryContext,
    recommendations: IntelligentRecommendation[],
    conversationHistory: any[]
  ): Promise<KnowledgeResponse> {
    // Obtener respuesta base del conocimiento
    let response = this.generateSmartResponse(intent, userRole, securityContext);

    // Personalizar respuesta seg√∫n el agente
    response = this.personalizeResponseForAgent(response, agent, sentiment, memoryContext);

    // Agregar recomendaciones inteligentes
    if (recommendations.length > 0) {
      response.response += '\n\nüí° **Recomendaciones inteligentes:**';
      for (const rec of recommendations.slice(0, 2)) {
        response.response += `\n‚Ä¢ ${rec.action} - ${rec.reason}`;
      }
    }

    // Agregar contexto de memoria si es relevante
    if (memoryContext.unresolvedIssues.length > 0) {
      response.response +=
        '\n\nüìã **Asuntos pendientes:** Recuerda que tenemos temas pendientes de resolver.';
    }

    // Agregar firma del agente
    if (agent) {
      response.response += `\n\n‚Äî ${agent.name}, ${agent.specialty}`;
    }

    response.agent = agent;
    response.sentiment = sentiment;
    response.memoryContext = memoryContext;
    response.recommendations = recommendations;

    return response;
  }

  /**
   * üé≠ Personalizar respuesta seg√∫n personalidad del agente
   */
  private personalizeResponseForAgent(
    baseResponse: KnowledgeResponse,
    agent: SpecializedAgent | undefined,
    sentiment: SentimentAnalysis,
    memoryContext: MemoryContext
  ): KnowledgeResponse {
    let response = baseResponse.response;

    // Ajustar tono seg√∫n personalidad del agente
    if (agent && agent.personality.empathy > 7 && sentiment.emotion === 'anger') {
      response = `Entiendo tu frustraci√≥n y quiero ayudarte. ${response}`;
    }

    if (agent && agent.personality.patience > 8 && sentiment.emotion === 'fear') {
      response = `T√≥mate tu tiempo, estamos aqu√≠ para ayudarte. ${response}`;
    }

    if (agent && agent.personality.tone === 'friendly') {
      response = response.replace(/usted/g, 't√∫').replace(/Usted/g, 'T√∫');
    }

    return { ...baseResponse, response };
  }

  /**
   * üíæ Sistema de memoria conversacional
   */
  private loadUserMemory(userId: string): ConversationMemory[] {
    return this.conversationMemory.get(userId) || [];
  }

  private saveToMemory(userId: string, memory: ConversationMemory): void {
    const userMemories = this.loadUserMemory(userId);
    userMemories.push(memory);

    // Mantener solo las √∫ltimas 50 conversaciones
    if (userMemories.length > 50) {
      userMemories.splice(0, userMemories.length - 50);
    }

    this.conversationMemory.set(userId, userMemories);
  }

  private buildMemoryContext(
    memories: ConversationMemory[],
    currentMessage: string
  ): MemoryContext {
    const recentMemories = memories.slice(-10); // √öltimas 10 conversaciones

    return {
      previousTopics: [...new Set(recentMemories.map(m => m.topic))],
      unresolvedIssues: recentMemories
        .filter(m => m.outcome === 'in_progress' || m.outcome === 'clarification_needed')
        .map(m => m.topic),
      successfulPatterns: recentMemories.filter(m => m.outcome === 'resolved').map(m => m.topic),
      userPreferences: this.extractUserPreferencesFromMemory(recentMemories),
      contextSummary: this.generateMemorySummary(recentMemories),
    };
  }

  private extractUserPreferencesFromMemory(memories: ConversationMemory[]): Record<string, any> {
    const prefs: Record<string, any> = {};

    // Analizar patrones de √©xito
    const successfulTopics = memories.filter(m => m.outcome === 'resolved').map(m => m.topic);

    if (successfulTopics.length > 0) {
      prefs.preferredTopics = successfulTopics;
    }

    return prefs;
  }

  private generateMemorySummary(memories: ConversationMemory[]): string {
    if (memories.length === 0) {
      return 'Nueva conversaci√≥n';
    }

    const topics = [...new Set(memories.map(m => m.topic))];
    const avgSatisfaction =
      memories
        .filter(m => m.userSatisfaction)
        .reduce((sum, m) => sum + (m.userSatisfaction || 0), 0) / memories.length;

    return `Conversaciones previas sobre: ${topics.join(', ')}. Satisfacci√≥n promedio: ${avgSatisfaction?.toFixed(1) || 'N/A'}`;
  }

  /**
   * üìà Aprendizaje autom√°tico continuo
   */
  private learnFromInteraction(
    userId: string,
    message: string,
    response: string,
    sentiment: SentimentAnalysis
  ): void {
    // Aprender de sentimientos negativos para mejorar
    if (sentiment.emotion === 'anger' || sentiment.emotion === 'sadness') {
      this.continuousLearning.learnFromInteraction(
        userId,
        message,
        response,
        'failure',
        sentiment.intensity * 2 // Convertir a escala 1-5
      );
    } else if (sentiment.emotion === 'joy') {
      this.continuousLearning.learnFromInteraction(
        userId,
        message,
        response,
        'success',
        sentiment.intensity * 5
      );
    }
  }

  /**
   * üõ†Ô∏è Utilidades auxiliares
   */
  private isAgentSuitableForRole(agent: SpecializedAgent, userRole: string): boolean {
    const roleAgentMapping: Record<string, string[]> = {
      tenant: [
        'general_assistant',
        'property_expert',
        'financial_advisor',
        'maintenance_specialist',
      ],
      owner: [
        'general_assistant',
        'property_expert',
        'financial_advisor',
        'maintenance_specialist',
      ],
      broker: ['general_assistant', 'broker_consultant', 'property_expert', 'financial_advisor'],
      provider: ['general_assistant', 'maintenance_specialist', 'financial_advisor'],
      admin: ['general_assistant', 'technical_support', 'legal_expert'],
    };

    return roleAgentMapping[userRole]?.includes(agent.id) || false;
  }

  /**
   * Procesar mensaje con IA avanzada (compatibilidad hacia atr√°s)
   */
  async processMessageAdvanced(
    userMessage: string,
    userRole: string,
    userId: string,
    conversationHistory: any[] = []
  ): Promise<{
    response: string;
    confidence: number;
    intent: string;
    suggestions?: string[] | undefined;
    actions?: string[] | undefined;
    links?: string[] | undefined;
    followUp?: string[] | undefined;
    securityNote?: string | undefined;
  }> {
    try {
      // Crear contexto de seguridad
      const securityContext = this.createSecurityContext(userRole, userId);

      // Reconocer intenci√≥n del mensaje
      const intent = this.recognizeIntent(userMessage, userRole);

      // Generar respuesta inteligente
      const smartResponse = this.generateSmartResponse(intent, userRole, securityContext);

      // Si la confianza es baja, intentar con IA externa usando el m√©todo existente
      if (smartResponse.confidence < 0.7 && this.config?.provider !== 'local') {
        try {
          const aiResult = await this.processMessage(
            userMessage,
            userRole,
            userId,
            conversationHistory
          );
          if (aiResult.response && aiResult.response !== smartResponse.response) {
            // Combinar respuesta local con IA para mejor resultado
            smartResponse.response = this.enhanceWithAI(smartResponse.response, aiResult.response);
            smartResponse.confidence = Math.max(smartResponse.confidence, 0.8);
          }
        } catch (aiError) {
          logger.warn('Error con IA externa, usando respuesta local:', { error: aiError });
        }
      }

      return {
        response: smartResponse.response,
        confidence: smartResponse.confidence,
        intent: intent.intent,
        suggestions: smartResponse.suggestions,
        actions: smartResponse.actions,
        links: smartResponse.links,
        followUp: smartResponse.followUp,
        securityNote: smartResponse.securityNote,
      };
    } catch (error) {
      logger.error('Error procesando mensaje avanzado:', {
        error: error instanceof Error ? error.message : String(error),
      });
      // Generar respuesta de fallback con el formato correcto
      const fallback = this.generateFallbackResponse(userRole);
      return {
        response: fallback.response,
        confidence: fallback.confidence,
        intent: 'support',
        suggestions: fallback.suggestions,
        links: fallback.links,
      };
    }
  }

  /**
   * Mejorar respuesta local con IA externa
   */
  private enhanceWithAI(localResponse: string, aiResponse: string): string {
    // Combinar respuestas de manera inteligente
    if (aiResponse.length > localResponse.length * 0.5) {
      return `${localResponse}\n\n${aiResponse}`;
    }
    return localResponse;
  }

  /**
   * Inicializa los proveedores de IA disponibles
   */
  private async initializeAIProviders(): Promise<void> {
    try {
      // Intentar inicializar OpenAI
      const openaiKey = process.env.OPENAI_API_KEY;
      if (openaiKey) {
        this.openai = new OpenAI({
          apiKey: openaiKey,
        });
        this.config = {
          provider: 'openai',
          apiKey: openaiKey,
          model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
          maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '1000'),
          temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.7'),
        };
        logger.info('OpenAI inicializado para chatbot');
        return;
      }

      // Intentar inicializar Anthropic (Claude)
      const anthropicKey = process.env.ANTHROPIC_API_KEY;
      if (anthropicKey) {
        this.anthropic = new Anthropic({
          apiKey: anthropicKey,
        });
        this.config = {
          provider: 'anthropic',
          apiKey: anthropicKey,
          model: process.env.ANTHROPIC_MODEL || 'claude-3-sonnet-20240229',
          maxTokens: parseInt(process.env.ANTHROPIC_MAX_TOKENS || '1000'),
          temperature: parseFloat(process.env.ANTHROPIC_TEMPERATURE || '0.7'),
        };
        logger.info('Anthropic inicializado para chatbot');
        return;
      }

      // Intentar inicializar Google AI
      const googleKey = process.env.GOOGLE_AI_API_KEY;
      if (googleKey) {
        this.googleAI = new GoogleGenerativeAI(googleKey);
        this.config = {
          provider: 'google',
          apiKey: googleKey,
          model: process.env.GOOGLE_MODEL || 'gemini-pro',
          maxTokens: parseInt(process.env.GOOGLE_MAX_TOKENS || '1000'),
          temperature: parseFloat(process.env.GOOGLE_TEMPERATURE || '0.7'),
        };
        logger.info('Google AI inicializado para chatbot');
        return;
      }

      // Si no hay proveedores externos, usar l√≥gica local
      this.config = {
        provider: 'local',
        apiKey: '',
        model: 'local-logic',
        maxTokens: 1000,
        temperature: 0.7,
      };
      logger.info('Usando l√≥gica local para chatbot (sin IA externa)');
    } catch (error) {
      logger.error('Error inicializando proveedores de IA:', {
        error: error instanceof Error ? error.message : String(error),
      });
      // Fallback a l√≥gica local
      this.config = {
        provider: 'local',
        apiKey: '',
        model: 'local-logic',
        maxTokens: 1000,
        temperature: 0.7,
      };
    }
  }

  /**
   * Procesa un mensaje del usuario y genera respuesta
   */
  async processMessage(
    userMessage: string,
    userRole: string,
    userId: string,
    conversationHistory?: Array<{ role: 'user' | 'assistant'; content: string }>
  ): Promise<{
    response: string;
    confidence: number;
    intent?: string;
    suggestions?: string[];
    metadata?: Record<string, any> | undefined;
  }> {
    try {
      if (!this.config) {
        throw new Error('Servicio de IA no inicializado');
      }

      // Crear contexto de seguridad
      const securityContext = this.createSecurityContext(userRole, userId);

      // Crear prompt con restricciones de seguridad
      const prompt = this.createSecurePrompt(userMessage, securityContext, conversationHistory);

      let response: string;
      let confidence: number;

      // Usar el proveedor de IA configurado
      switch (this.config.provider) {
        case 'openai':
          ({ response, confidence } = await this.processWithOpenAI(prompt));
          break;

        case 'anthropic':
          ({ response, confidence } = await this.processWithAnthropic(prompt));
          break;

        case 'google':
          ({ response, confidence } = await this.processWithGoogle(prompt));
          break;

        case 'local':
        default:
          ({ response, confidence } = await this.processWithLocalLogic(userMessage, userRole));
          break;
      }

      // Validar respuesta por seguridad
      const validatedResponse = this.validateResponse(response, securityContext);

      // Extraer informaci√≥n adicional
      const intent = this.extractIntent(userMessage);
      const suggestions = this.generateSuggestions(userMessage, userRole);

      logger.info('Mensaje procesado por IA', {
        userId,
        userRole,
        intent,
        confidence,
        provider: this.config.provider,
      });

      return {
        response: validatedResponse,
        confidence,
        intent,
        suggestions,
        metadata: {
          provider: this.config.provider,
          model: this.config.model,
          processingTime: Date.now(),
        },
      };
    } catch (error) {
      logger.error('Error procesando mensaje:', {
        error: error instanceof Error ? error.message : String(error),
      });

      // Respuesta de fallback segura
      return {
        response:
          'Lo siento, tuve un problema procesando tu consulta. ¬øPodr√≠as reformular tu pregunta?',
        confidence: 0,
        suggestions: ['Buscar propiedades', 'Ver contratos', 'Contactar soporte'],
      };
    }
  }

  /**
   * Procesa con OpenAI
   */
  private async processWithOpenAI(
    prompt: string
  ): Promise<{ response: string; confidence: number }> {
    if (!this.openai) {
      throw new Error('OpenAI no inicializado');
    }

    const completion = await this.openai.chat.completions.create({
      model: this.config!.model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: this.config!.maxTokens,
      temperature: this.config!.temperature,
    });

    const response =
      completion.choices[0]?.message?.content || 'Lo siento, no pude generar una respuesta.';
    const confidence = 0.85; // OpenAI generalmente tiene alta confianza

    return { response, confidence };
  }

  /**
   * Procesa con Anthropic (Claude)
   */
  private async processWithAnthropic(
    prompt: string
  ): Promise<{ response: string; confidence: number }> {
    if (!this.anthropic) {
      throw new Error('Anthropic no inicializado');
    }

    const message = await this.anthropic.messages.create({
      model: this.config!.model,
      max_tokens: this.config!.maxTokens,
      temperature: this.config!.temperature,
      messages: [{ role: 'user', content: prompt }],
    });

    const response =
      message.content[0]?.type === 'text'
        ? message.content[0]?.text
        : 'Lo siento, no pude generar una respuesta.';
    const confidence = 0.9; // Claude generalmente tiene muy alta confianza

    return { response, confidence };
  }

  /**
   * Procesa con Google AI
   */
  private async processWithGoogle(
    prompt: string
  ): Promise<{ response: string; confidence: number }> {
    if (!this.googleAI) {
      throw new Error('Google AI no inicializado');
    }

    const model = this.googleAI.getGenerativeModel({ model: this.config!.model });
    const result = await model.generateContent(prompt);
    const response = result.response.text();

    const confidence = 0.8; // Google AI tiene buena confianza

    return { response, confidence };
  }

  /**
   * Procesa con l√≥gica local (sin IA externa)
   */
  private async processWithLocalLogic(
    userMessage: string,
    userRole: string
  ): Promise<{ response: string; confidence: number }> {
    const input = userMessage.toLowerCase();

    // L√≥gica simple basada en palabras clave
    if (input.includes('propiedad') || input.includes('casa') || input.includes('departamento')) {
      return {
        response:
          'Te ayudo a buscar propiedades. Puedo mostrarte opciones seg√∫n tu ubicaci√≥n, presupuesto y preferencias. ¬øEn qu√© zona te interesa vivir y cu√°l es tu presupuesto mensual?',
        confidence: 0.95,
      };
    }

    if (input.includes('contrato') || input.includes('arriendo') || input.includes('alquiler')) {
      return {
        response:
          'Para gestionar contratos, puedes acceder a la secci√≥n "Mis Contratos" donde encontrar√°s todos tus documentos, fechas de vencimiento y opciones de renovaci√≥n. ¬øNecesitas ayuda con alg√∫n contrato espec√≠fico?',
        confidence: 0.9,
      };
    }

    if (input.includes('pago') || input.includes('renta') || input.includes('dinero')) {
      return {
        response:
          'Para realizar pagos, puedes usar la secci√≥n "Pagos" donde encontrar√°s m√∫ltiples m√©todos de pago seguros. Tambi√©n puedes configurar pagos autom√°ticos para no olvidarte. ¬øQu√© m√©todo prefieres usar?',
        confidence: 0.85,
      };
    }

    if (
      input.includes('problema') ||
      input.includes('mantenimiento') ||
      input.includes('reparar')
    ) {
      return {
        response:
          'Para reportar un problema de mantenimiento, puedes crear un ticket en la secci√≥n "Mantenimiento". Te ayudar√© a categorizar el problema y asignar la prioridad correcta. ¬øQu√© tipo de problema tienes?',
        confidence: 0.8,
      };
    }

    // Respuesta por defecto
    return {
      response:
        'Entiendo tu consulta. Te puedo ayudar con b√∫squeda de propiedades, gesti√≥n de contratos, pagos, mantenimiento y configuraci√≥n de tu cuenta. ¬øQu√© te gustar√≠a hacer?',
      confidence: 0.6,
    };
  }

  /**
   * Crea contexto de seguridad basado en el rol del usuario
   */
  private createSecurityContext(
    userRole: string,
    userId: string
  ): {
    allowedTopics: string[];
    restrictedTopics: string[];
    maxDataAccess: string;
    canExecuteActions: boolean;
  } {
    const context = {
      allowedTopics: [] as string[],
      restrictedTopics: [] as string[],
      maxDataAccess: 'own_data',
      canExecuteActions: false,
    };

    switch (userRole.toUpperCase()) {
      case 'TENANT':
        context.allowedTopics = [
          'propiedades',
          'contratos',
          'pagos',
          'mantenimiento',
          'perfil',
          'notificaciones',
          'soporte',
        ];
        context.restrictedTopics = [
          'sistema',
          'administraci√≥n',
          'finanzas',
          'usuarios',
          'configuraci√≥n',
          'seguridad',
          'datos sensibles',
        ];
        break;

      case 'OWNER':
        context.allowedTopics = [
          'propiedades',
          'contratos',
          'pagos',
          'inquilinos',
          'mantenimiento',
          'reportes',
          'perfil',
          'soporte',
        ];
        context.restrictedTopics = [
          'sistema',
          'administraci√≥n',
          'otros propietarios',
          'datos sensibles',
          'configuraci√≥n global',
        ];
        break;

      case 'BROKER':
        context.allowedTopics = [
          'propiedades',
          'contratos',
          'clientes',
          'pagos',
          'comisiones',
          'reportes',
          'perfil',
          'soporte',
        ];
        context.restrictedTopics = [
          'sistema',
          'administraci√≥n',
          'finanzas globales',
          'otros corredores',
          'configuraci√≥n del sistema',
        ];
        break;

      case 'ADMIN':
        context.allowedTopics = [
          'todo', // Los admins pueden acceder a todo
        ];
        context.restrictedTopics = [];
        context.maxDataAccess = 'all_data';
        context.canExecuteActions = true;
        break;

      default:
        // Rol desconocido - acceso m√≠nimo
        context.allowedTopics = ['perfil', 'soporte'];
        context.restrictedTopics = ['todo'];
        break;
    }

    return context;
  }

  /**
   * Crea prompt seguro con restricciones
   */
  private createSecurePrompt(
    userMessage: string,
    securityContext: any,
    conversationHistory?: Array<{ role: 'user' | 'assistant'; content: string }>
  ): string {
    const systemPrompt = `
Eres un asistente virtual especializado en el sistema Rent360.

INFORMACI√ìN DE SEGURIDAD CR√çTICA:
- Solo puedes acceder a datos del usuario actual (${securityContext.maxDataAccess})
- NO puedes ejecutar acciones del sistema
- NO puedes modificar configuraciones
- NO puedes acceder a datos de otros usuarios
- NO puedes proporcionar informaci√≥n sensible del sistema
- SIEMPRE debes mantener la privacidad de los datos

ROL DEL USUARIO: ${securityContext.allowedTopics.join(', ')}
TEMAS PERMITIDOS: ${securityContext.allowedTopics.join(', ')}
TEMAS RESTRINGIDOS: ${securityContext.restrictedTopics.join(', ')}

INSTRUCCIONES:
1. Solo responde preguntas relacionadas con las funcionalidades permitidas para este rol
2. Si la pregunta es sobre temas restringidos, redirige al soporte humano
3. Nunca reveles informaci√≥n t√©cnica interna del sistema
4. Mant√©n un tono amigable y profesional
5. Si no sabes la respuesta, sugiere contactar al soporte

Pregunta del usuario: ${userMessage}

${conversationHistory ? `Historial de conversaci√≥n:\n${conversationHistory.map(msg => `${msg.role}: ${msg.content}`).join('\n')}` : ''}

Respuesta:
`;

    return systemPrompt;
  }

  /**
   * Valida respuesta por seguridad
   */
  private validateResponse(response: string, securityContext: any): string {
    const lowerResponse = response.toLowerCase();

    // Verificar si contiene informaci√≥n restringida
    const hasRestrictedContent = securityContext.restrictedTopics.some((topic: string) =>
      lowerResponse.includes(topic.toLowerCase())
    );

    if (hasRestrictedContent) {
      return 'Lo siento, no puedo proporcionar informaci√≥n sobre ese tema. Te recomiendo contactar al soporte t√©cnico para obtener ayuda especializada.';
    }

    // Verificar si intenta ejecutar acciones
    const actionKeywords = ['eliminar', 'borrar', 'modificar', 'cambiar', 'actualizar', 'crear'];
    const hasActionKeywords = actionKeywords.some(keyword => lowerResponse.includes(keyword));

    if (hasActionKeywords && !securityContext.canExecuteActions) {
      return 'Para realizar cambios en tu cuenta o ejecutar acciones, por favor accede directamente a las secciones correspondientes del sistema o contacta al soporte.';
    }

    return response;
  }

  /**
   * Extrae intenci√≥n del mensaje
   */
  private extractIntent(userMessage: string): string {
    const input = userMessage.toLowerCase();

    if (input.includes('buscar') || input.includes('encontrar')) {
      return 'search';
    }
    if (input.includes('contrato') || input.includes('arriendo')) {
      return 'contracts';
    }
    if (input.includes('pago') || input.includes('renta')) {
      return 'payments';
    }
    if (input.includes('problema') || input.includes('mantenimiento')) {
      return 'maintenance';
    }
    if (input.includes('configur') || input.includes('ajuste')) {
      return 'settings';
    }
    if (input.includes('ayuda') || input.includes('soporte')) {
      return 'support';
    }

    return 'general';
  }

  /**
   * Genera sugerencias basadas en el mensaje
   */
  private generateSuggestions(userMessage: string, userRole: string): string[] {
    const suggestions: string[] = [];
    const input = userMessage.toLowerCase();

    if (input.includes('propiedad')) {
      suggestions.push('Buscar propiedades disponibles');
      suggestions.push('Filtrar por zona');
      suggestions.push('Calcular presupuesto');
    }

    if (input.includes('contrato')) {
      suggestions.push('Ver contratos activos');
      suggestions.push('Renovar contrato');
      suggestions.push('Descargar documento');
    }

    if (input.includes('pago')) {
      suggestions.push('Realizar pago');
      suggestions.push('Ver historial');
      suggestions.push('Configurar pagos autom√°ticos');
    }

    if (input.includes('problema') || input.includes('mantenimiento')) {
      suggestions.push('Crear ticket');
      suggestions.push('Ver tickets activos');
      suggestions.push('Contactar soporte');
    }

    // Sugerencias generales si no hay espec√≠ficas
    if (suggestions.length === 0) {
      suggestions.push('Buscar propiedades');
      suggestions.push('Ver contratos');
      suggestions.push('Realizar pago');
      suggestions.push('Reportar problema');
    }

    return suggestions.slice(0, 3); // M√°ximo 3 sugerencias
  }

  /**
   * Verifica si hay alg√∫n proveedor de IA disponible
   */
  getAvailableProviders(): {
    openai: boolean;
    anthropic: boolean;
    google: boolean;
    local: boolean;
    current: string;
  } {
    return {
      openai: !!this.openai,
      anthropic: !!this.anthropic,
      google: !!this.googleAI,
      local: true,
      current: this.config?.provider || 'local',
    };
  }

  /**
   * Cambia el proveedor de IA
   */
  async switchProvider(provider: 'openai' | 'anthropic' | 'google' | 'local'): Promise<boolean> {
    try {
      // Re-inicializar con el nuevo proveedor
      const oldConfig = { ...this.config };

      // Limpiar configuraciones anteriores
      this.openai = null;
      this.anthropic = null;
      this.googleAI = null;

      // Forzar re-inicializaci√≥n
      await this.initializeAIProviders();

      const success = this.config?.provider === provider;

      if (success) {
        logger.info(`Proveedor de IA cambiado: ${oldConfig.provider} -> ${provider}`);
      } else {
        logger.warn(`No se pudo cambiar a proveedor ${provider}, usando ${this.config?.provider}`);
      }

      return success;
    } catch (error) {
      logger.error('Error cambiando proveedor de IA:', {
        error: error instanceof Error ? error.message : String(error),
      });
      return false;
    }
  }
}

// Instancia singleton del servicio
export const aiChatbotService = new AIChatbotService();
