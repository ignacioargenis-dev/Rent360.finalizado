import { db } from './db';
import { logger } from './logger';

/**
 * Servicio de Notificaciones en Tiempo Real
 * Gestiona la creaci√≥n y env√≠o de notificaciones a usuarios
 */

export enum NotificationType {
  // Invitaciones
  INVITATION_RECEIVED = 'INVITATION_RECEIVED',
  INVITATION_ACCEPTED = 'INVITATION_ACCEPTED',
  INVITATION_REJECTED = 'INVITATION_REJECTED',

  // Solicitudes de Servicio
  SERVICE_REQUEST_RESPONSE = 'SERVICE_REQUEST_RESPONSE',
  SERVICE_REQUEST_ACCEPTED = 'SERVICE_REQUEST_ACCEPTED',
  SERVICE_REQUEST_REJECTED = 'SERVICE_REQUEST_REJECTED',

  // Recomendaciones
  NEW_RECOMMENDATIONS = 'NEW_RECOMMENDATIONS',

  // Prospects
  PROSPECT_CONVERTED = 'PROSPECT_CONVERTED',
  PROSPECT_ACTIVITY = 'PROSPECT_ACTIVITY',

  // General
  NEW_MESSAGE = 'NEW_MESSAGE',
  SYSTEM_ALERT = 'SYSTEM_ALERT',
}

export interface CreateNotificationParams {
  userId: string;
  type: NotificationType | string;
  title: string;
  message: string;
  link?: string;
  metadata?: any;
  priority?: 'low' | 'medium' | 'high';
}

export class NotificationService {
  /**
   * Crea una nueva notificaci√≥n para un usuario
   */
  static async create(params: CreateNotificationParams): Promise<any> {
    try {
      const notification = await db.notification.create({
        data: {
          userId: params.userId,
          type: params.type,
          title: params.title,
          message: params.message,
          link: params.link,
          metadata: params.metadata ? JSON.stringify(params.metadata) : null,
          isRead: false,
          priority: params.priority || 'medium',
        },
      });

      logger.info('üì¨ Notification created', {
        notificationId: notification.id,
        userId: params.userId,
        type: params.type,
      });

      return notification;
    } catch (error) {
      logger.error('Error creating notification', {
        error: error instanceof Error ? error.message : String(error),
        params,
      });
      throw error;
    }
  }

  /**
   * Crea notificaci√≥n cuando un corredor env√≠a una invitaci√≥n
   */
  static async notifyInvitationReceived(params: {
    userId: string;
    brokerName: string;
    brokerId: string;
    invitationType: string;
    invitationId: string;
  }) {
    const invitationTypeLabels: any = {
      SERVICE_OFFER: 'oferta de servicios',
      PROPERTY_MANAGEMENT: 'gesti√≥n de propiedades',
      PROPERTY_VIEWING: 'visualizaci√≥n de propiedades',
      CONSULTATION: 'consultor√≠a',
    };

    return this.create({
      userId: params.userId,
      type: NotificationType.INVITATION_RECEIVED,
      title: 'üì® Nueva Invitaci√≥n de Corredor',
      message: `${params.brokerName} te ha enviado una ${invitationTypeLabels[params.invitationType] || 'invitaci√≥n'}`,
      link: `/owner/broker-services`, // TODO: Link espec√≠fico a la invitaci√≥n
      priority: 'high',
      metadata: {
        brokerId: params.brokerId,
        invitationId: params.invitationId,
        invitationType: params.invitationType,
      },
    });
  }

  /**
   * Crea notificaci√≥n cuando un usuario acepta una invitaci√≥n
   */
  static async notifyInvitationAccepted(params: {
    brokerId: string;
    userName: string;
    userId: string;
    invitationId: string;
  }) {
    return this.create({
      userId: params.brokerId,
      type: NotificationType.INVITATION_ACCEPTED,
      title: '‚úÖ Invitaci√≥n Aceptada',
      message: `${params.userName} ha aceptado tu invitaci√≥n`,
      link: `/broker/prospects`,
      priority: 'high',
      metadata: {
        userId: params.userId,
        invitationId: params.invitationId,
      },
    });
  }

  /**
   * Crea notificaci√≥n cuando un usuario rechaza una invitaci√≥n
   */
  static async notifyInvitationRejected(params: {
    brokerId: string;
    userName: string;
    userId: string;
    invitationId: string;
  }) {
    return this.create({
      userId: params.brokerId,
      type: NotificationType.INVITATION_REJECTED,
      title: '‚ùå Invitaci√≥n Rechazada',
      message: `${params.userName} ha rechazado tu invitaci√≥n`,
      link: `/broker/discover`,
      priority: 'medium',
      metadata: {
        userId: params.userId,
        invitationId: params.invitationId,
      },
    });
  }

  /**
   * Crea notificaci√≥n cuando un corredor responde a una solicitud
   */
  static async notifyServiceRequestResponse(params: {
    userId: string;
    brokerName: string;
    brokerId: string;
    requestId: string;
    requestTitle: string;
  }) {
    return this.create({
      userId: params.userId,
      type: NotificationType.SERVICE_REQUEST_RESPONSE,
      title: 'üí¨ Nueva Propuesta Recibida',
      message: `${params.brokerName} ha respondido a tu solicitud: ${params.requestTitle}`,
      link: `/owner/broker-services`,
      priority: 'high',
      metadata: {
        brokerId: params.brokerId,
        requestId: params.requestId,
      },
    });
  }

  /**
   * Crea notificaci√≥n cuando un usuario acepta una propuesta
   */
  static async notifyResponseAccepted(params: {
    brokerId: string;
    userName: string;
    userId: string;
    requestId: string;
    requestTitle: string;
  }) {
    return this.create({
      userId: params.brokerId,
      type: NotificationType.SERVICE_REQUEST_ACCEPTED,
      title: 'üéâ Propuesta Aceptada',
      message: `${params.userName} ha aceptado tu propuesta para: ${params.requestTitle}`,
      link: `/broker/discover`,
      priority: 'high',
      metadata: {
        userId: params.userId,
        requestId: params.requestId,
      },
    });
  }

  /**
   * Crea notificaci√≥n cuando un usuario rechaza una propuesta
   */
  static async notifyResponseRejected(params: {
    brokerId: string;
    userName: string;
    userId: string;
    requestId: string;
  }) {
    return this.create({
      userId: params.brokerId,
      type: NotificationType.SERVICE_REQUEST_REJECTED,
      title: 'Propuesta Rechazada',
      message: `${params.userName} ha rechazado tu propuesta`,
      link: `/broker/discover`,
      priority: 'low',
      metadata: {
        userId: params.userId,
        requestId: params.requestId,
      },
    });
  }

  /**
   * Crea notificaci√≥n de nuevas recomendaciones generadas
   */
  static async notifyNewRecommendations(params: {
    brokerId: string;
    count: number;
    ownersCount: number;
    tenantsCount: number;
  }) {
    return this.create({
      userId: params.brokerId,
      type: NotificationType.NEW_RECOMMENDATIONS,
      title: '‚ú® Nuevas Recomendaciones',
      message: `Se han generado ${params.count} nuevas recomendaciones (${params.ownersCount} propietarios, ${params.tenantsCount} inquilinos)`,
      link: `/broker/discover`,
      priority: 'medium',
      metadata: {
        count: params.count,
        ownersCount: params.ownersCount,
        tenantsCount: params.tenantsCount,
      },
    });
  }

  /**
   * Obtiene notificaciones no le√≠das de un usuario
   */
  static async getUnread(userId: string) {
    try {
      const notifications = await db.notification.findMany({
        where: {
          userId,
          isRead: false,
        },
        orderBy: {
          createdAt: 'desc',
        },
        take: 50,
      });

      return notifications;
    } catch (error) {
      logger.error('Error fetching unread notifications', {
        error: error instanceof Error ? error.message : String(error),
        userId,
      });
      return [];
    }
  }

  /**
   * Marca una notificaci√≥n como le√≠da
   */
  static async markAsRead(notificationId: string, userId: string) {
    try {
      await db.notification.updateMany({
        where: {
          id: notificationId,
          userId, // Seguridad: solo el due√±o puede marcarla
        },
        data: {
          isRead: true,
          readAt: new Date(),
        },
      });

      logger.info('‚úì Notification marked as read', {
        notificationId,
        userId,
      });
    } catch (error) {
      logger.error('Error marking notification as read', {
        error: error instanceof Error ? error.message : String(error),
        notificationId,
        userId,
      });
    }
  }

  /**
   * Marca todas las notificaciones como le√≠das
   */
  static async markAllAsRead(userId: string) {
    try {
      const result = await db.notification.updateMany({
        where: {
          userId,
          isRead: false,
        },
        data: {
          isRead: true,
          readAt: new Date(),
        },
      });

      logger.info('‚úì All notifications marked as read', {
        userId,
        count: result.count,
      });

      return result.count;
    } catch (error) {
      logger.error('Error marking all notifications as read', {
        error: error instanceof Error ? error.message : String(error),
        userId,
      });
      return 0;
    }
  }

  /**
   * Elimina una notificaci√≥n
   */
  static async delete(notificationId: string, userId: string) {
    try {
      await db.notification.deleteMany({
        where: {
          id: notificationId,
          userId, // Seguridad: solo el due√±o puede eliminarla
        },
      });

      logger.info('üóëÔ∏è Notification deleted', {
        notificationId,
        userId,
      });
    } catch (error) {
      logger.error('Error deleting notification', {
        error: error instanceof Error ? error.message : String(error),
        notificationId,
        userId,
      });
    }
  }
}
